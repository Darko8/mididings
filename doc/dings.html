<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">

<head>
  <title>mididings - Documentation</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <style type="text/css">
    body { max-width: 60em; font-size: 90%; }
    h1 { font-size: 130%; color: #333; background: #eee; padding: 4px 0.7em; }
    h2 { font-size: 110%; color: #fff; background: #667; padding: 4px 0.7em; margin-top: 1.5em; }
    h3 { font-size: 100%; color: #333; background: #dddde5; padding: 4px 0.7em; margin-top: 1.5em; }
    h4 { font-size: 100%; color: #333; padding-left: 0.5em; margin-bottom: 0.4em; }
    p,table,pre { margin-left: 0.8em; margin-top: 0.4em; }
    b { color: #333; }
    pre { font-size: 110%; }
    table { border: 1px solid #333; border-collapse: collapse; }
    th, td { border: 1px solid #333; padding: 0em 0.3em; }
    th { color: #333; text-align: left; background: #eee; }
    a { font-weight: bold; color: #237; }
  </style>
</head>

<body>

<h1>mididings - Documentation</h1>

<h2>Table of Contents</h2>
<ul>
  <li><a href="#basics">Basics</a>
    <ul>
      <li><a href="#functions">Functions</a></li>
      <li><a href="#connect">Making connections</a></li>
    </ul>
  </li>

  <li><a href="#units">Units</a>
    <ul>
      <li><a href="#filters">Filters</a></li>
      <li><a href="#splits">Splits</a></li>
      <li><a href="#modifiers">Modifiers</a></li>
      <li><a href="#misc">Miscellaneous</a></li>
    </ul>
  </li>

  <li><a href="#examples">Examples</a></li>
</ul>


<h2><a name="basics"></a>Basics</h2>

<p>
mididings configuration files are just Python scripts, although mididings uses some of Python's features in ways
for which they weren't intended ;)<br>
Basically, the MIDI processing setup is defined in Python, while the actual event processing is done entirely
in C++. It is however possible to explicitly call back into Python, if necessary.
</p>

<h3><a name="functions"></a>Functions</h3>

<h4>config(**kwargs)</h4>
<p>
Changes global mididings settings. This should be called only once, before constructing any processing units.
<br>
Possible keyword arguments are:
</p>
<ul>
  <li><b>client_name</b>: MIDI client name to be used.</li>
  <li><b>in_ports/out_ports</b>: Integers indicating the number of input/output ports to create (named in_<i>n</i>
  or out_<i>n</i>), or lists of port names, in which case the list's length determines the number of ports.</li>
  <li><b>data_offset</b>: 1 (default) or 0. Determines whether program, port and channel numbers will be
  in the range 1-128 or 0-127.</li>
  <li><b>octave_offset</b>: Default is 2, meaning that "Middle C" is designated as C3.</li>
  <li><b>start_delay</b>: The number of seconds before sending any MIDI events (i.e. switching to the first patch).
  A small value like 0.5 can be used to give tools like qjackctl's patchbay time to connect the ports.
  A value of 0 instructs mididings to wait for the user to press enter. Default is None.</li>
</ul>


<h4>run(patch)</h4>
<p>
Starts the actual MIDI processing. This is usually the last function called by a mididings script.
</p>
<ul>
  <li><b>patch</b>: A single patch.</li>
</ul>

<h4>run_patches(patches, control=None, pre=None, post=None)</h4>
<ul>
  <li><b>patches</b>: A dictionary with program numbers as keys, and patches as values.
  Values can also be tuple with two items, the first being an init-patch that's executed once every time the
  patch is selected, and the second being the actual patch that processes incoming events.</li>
  <li><b>control</b>: The "control" patch, which is always active, and run in parallel to the current patch.</li>
  <li><b>pre/post</b>: Allows processing to take place before/after every patch. Does not affect
  the control patch.</li>
</ul>


<h3><a name="connect"></a>Making connections</h3>

<h4>A &gt;&gt; B</h4>
<p>
Connects two units in series. Incoming MIDI events will be processed by unit A first, then by unit B.
If the event is filtered out by unit A, it is not processed any further, and unit B will not be called.
</p>

<h4>[ A, B, ... ]</h4>
<p>
Connects two or more units in parallel. All units will be called with identical copies of incoming MIDI
events. The output will be the sum of all the units' outputs.
</p>

<h4>{ T1: A, T2: B, ... }</h4>
<p>
Splits by event type. Equivalent to [ Filter(T1) &gt;&gt; A, Filter(T2) &gt;&gt; B, ... ].
</p>


<h2><a name="units"></a>Units</h2>

<p>
These are the basic building blocks from which you can build your patches. They can roughly be divided into 4 categories:
<ul>
  <li><b>Filters</b>: These units filter by some property of the MIDI event. If the event matches, it's passed
  unmodified, otherwise it's discarded.
  Events of different types (e.g. a note event going through a CtrlFilter) are also discarded.<br>
  Filters can be inverted by prepending operator ~.</li>
  <li><b>Splits</b>: Basically just combinations of multiple filters of the same kind.</li>
  <li><b>Modifiers</b>: These units change some property of the MIDI event.</li>
  <li><b>Miscellaneous</b>: Anything that doesn't fit into any of the other categories :)</li>
</ul>
<p>


<h3><a name="filters"></a>Filters</h3>

<h4>Filter(type, ...)</h4>
<p>
Filters by one or more event types.
Types must be one of: NOTE, NOTEON, NOTEOFF, CTRL, PITCHBEND, PROGRAM.
</p>

<h4>PortFilter(port, ...)<br>
ChannelFilter(channel, ...)</h4>
<p>
Filters by event port or channel.
</p>

<h4>KeyFilter(key)<br>
KeyFilter(lower, upper)<br>
KeyFilter(range)</h4>
<p>
Filters by key or key-range. Keys can be MIDI note numbers or note names (e.g. 'g#3').
Ranges can be 2-tuples of note numbers, or note names (e.g. 'g#3:c6').
</p>

<h4>VelocityFilter(min, max)</h4>
<p>
Filters by note velocity.
</p>

<h4>CtrlFilter(num, ...)</h4>
<p>
Filters by CC number.
</p>

<h4>CtrlValueFilter(value)<br>
CtrlValueFilter(min, max)</h4>
<p>
Filters by CC value.
</p>

<h4>ProgFilter(num, ...)</h4>
<p>
Filters by PC number.
</p>


<h3><a name="splits"></a>Splits</h3>

<h4>PortSplit({port: units, ...})<br>
ChannelSplit({channel: units, ...})</h4>
<p>
Splits by port or channel.
</p>

<h4>KeySplit(key, units_lower, units_upper)<br>
KeySplit({(lower, upper): units, ...})<br>
KeySplit({range: units, ...})</h4>
<p>
Splits by key. Non-note events are sent to all units.
</p>

<h4>VelocitySplit(threshold, units_lower, units_upper)<br>
VelocitySplit({(min, max): units, ...})</h4>
<p>
Splits by velocity. Non-note events are sent to all units.
</p>


<h3><a name="modifiers"></a>Modifiers</h3>

<h4>Port(port)<br>
Channel(channel)</h4>
<p>
Changes port or channel.
</p>

<h4>Transpose(offset)</h4>
<p>
Transposes all note events.
</p>

<h4>Velocity(offset)<br>
VelocityFixed(value)</h4>
<p>
Changes velocity, either by adding an offset, or by setting it to a fixed value.
</p>

<h4>VelocityCurve(gamma)</h4>
<p>
Applies a "gamma"-curve to all velocity values.
</p>

<h4>VelocityGradient(note_lower, note_upper, value_lower, value_upper)<br>
VelocityGradientFixed(note_lower, note_upper, value_lower, value_upper)</h4>
<p>
Changes velocity, using a gradient from lower to upper.
</p>

<h4>CtrlRange(num, out_min, out_max, in_min=0, in_max=127)</h4>
<p>
Maps controller range in to out.
</p>

<h4>CtrlChange(num, value)<br>
CtrlChange(port, channel, num, value)<br>
ProgChange(program)<br>
ProgChange(port, channel, program)</h4>
<p>
Changes the type of the event.
If port and channel are omitted, the values of the input event are used.
</p>


<h3><a name="misc"></a>Miscellaneous</h3>

<h4>Pass()</h4>
<p>
Does nothing.
</p>

<h4>Discard()</h4>
<p>
Discards all events.
</p>

<h4>PatchSwitch()<br>
PatchSwitch(patch)</h4>
<p>
Switches to another patch.
If patch is omitted, uses the number of the input event (should be a program change).
</p>

<h4>Call(function)</h4>
<p>
Calls a python function, with the event as its only argument.
The event is an object with the following attributes, all of which can be both read and written:
</p>
<ul>
  <li><b>type_</b>: The event type, one of NOTEON, NOTEOFF, CTRL, PITCHBEND, PROGRAM.</li>
  <li><b>port_</b>: The event port.</li>
  <li><b>channel_</b>: The event channel.</li>
  <li><b>data1, data2</b>: Data bytes, meaning depends on event type.</li>
</ul>
<p>
There are also aliases for these attributes, some of which are only meaningful for certain types of events:
</p>
<ul>
  <li><b>port</b>: Event port. Unlike port_, this value is affected by the data_offset setting.</li>
  <li><b>channel</b>: Event channel. Unlike channel_, this value is affected by the data_offset setting.</li>
  <li><b>note</b>: Note number, alias for data1.</li>
  <li><b>velocity</b>: Note velocity, alias for data2.</li>
  <li><b>param</b>: Controller number, alias for data1.</li>
  <li><b>value</b>: Controller parameter, alias for data2.</li>
  <li><b>program</b>: Program number, alias for data2. Unlike data2, this value is affected by the data_offset setting.</li>
</ul>
<p>
The function should return True to continue processing the event, or False to discard it.
</p>

<h4>Print()<br>
Print(name)</h4>
<p>
Prints event data.
</p>

<h4>Sanitize()</h4>
<p>
Makes sure the event is a valid MIDI message. Events with invalid port, channel, controller, program or note number are
discarded, note velocity and controller values are confined to the range 0-127.
</p>


<h2><a name="examples"></a>Examples</h2>

<ul>
  <li><a href="./example.py">example.py</a> - a very simple mididings setup</li>
  <li><a href="./example_patches.py">example_patches.py</a> - a simple example setup, demonstrating patch switching</li>
  <li><a href="./example_python.py">example_python.py</a> - shows how to process MIDI events in Python</li>
</ul>


</body>

</html>
