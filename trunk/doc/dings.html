<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">

<head>
  <title>mididings - Documentation</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <style type="text/css">
    body { max-width: 60em; font-size: 90%; }
    h1 { font-size: 130%; color: #333; background: #eee; padding: 4px 0.7em; }
    h2 { font-size: 110%; color: #fff; background: #667; padding: 4px 0.7em; margin-top: 1.5em; }
    h3 { font-size: 100%; color: #333; background: #dddde5; padding: 4px 0.7em; margin-top: 1.5em; }
    h4 { font-size: 100%; color: #333; padding-left: 0.5em; margin-bottom: 0.4em; }
    p,table,pre { margin-left: 1.6em; margin-top: 0.4em; }
    b { color: #333; }
    pre { font-size: 110%; }
    table { border: 1px solid #333; border-collapse: collapse; }
    th, td { border: 1px solid #333; padding: 0em 0.3em; }
    th { color: #333; text-align: left; background: #eee; }
    a { font-weight: bold; color: #237; }
  </style>
</head>

<body>

<h1>mididings - Documentation</h1>

<h2>Table of Contents</h2>
<ul>
  <li><a href="#basics">Basics</a>
    <ul>
      <li><a href="#functions">Functions</a></li>
      <li><a href="#types">Data Types</a></li>
      <li><a href="#constants">Constants</a></li>
      <li><a href="#connect">Making Connections</a></li>
    </ul>
  </li>

  <li><a href="#units">Units</a>
    <ul>
      <li><a href="#filters">Filters</a></li>
      <li><a href="#splits">Splits</a></li>
      <li><a href="#modifiers">Modifiers</a></li>
      <li><a href="#generators">Generators</a></li>
      <li><a href="#calls">Function Calls</a></li>
      <li><a href="#misc">Miscellaneous</a></li>
    </ul>
  </li>

  <li><a href="#examples">Examples</a></li>
</ul>



<h2><a name="basics"></a>Basics</h2>

<p>
mididings configuration files are just Python scripts, although mididings uses some of Python's features in ways
for which they weren't intended ;)<br>
Basically, the MIDI processing setup is defined in Python, while the actual event processing is done entirely
in C++. It is however possible to explicitly call back into Python, if necessary.
</p>


<h3><a name="functions"></a>Functions</h3>

<h4>config(**kwargs)</h4>
<p>
Changes global mididings settings. This should be called only once, before constructing any processing units.
<br>
Possible keyword arguments are:
</p>
<ul>
  <li><b>client_name</b>: MIDI client name to be used.</li>
  <li><b>in_ports/out_ports</b>: Integers indicating the number of input/output ports to create (named in_<i>n</i>
  or out_<i>n</i>), or lists of port names, in which case the list's length determines the number of ports.</li>
  <li><b>data_offset</b>: 1 (default) or 0. Determines whether program, port and channel numbers will be
  in the range 1-128 or 0-127.</li>
  <li><b>octave_offset</b>: Default is 2, meaning that "Middle C" is designated as C3.</li>
  <li><b>start_delay</b>: The number of seconds before sending any MIDI events (i.e. switching to the first patch).
  A small value like 0.5 can be used to give tools like qjackctl's patchbay time to connect the ports.
  A value of 0 instructs mididings to wait for the user to press enter. Default is None.</li>
</ul>


<h4>run(patch)</h4>
<p>
Starts the actual MIDI processing. This is usually the last function called by a mididings script.
</p>
<ul>
  <li><b>patch</b>: A single patch.</li>
</ul>

<h4>run_patches(patches, control=None, pre=None, post=None)</h4>
<p>
Starts the actual MIDI processing, using multiple patches.
</p>
<ul>
  <li><b>patches</b>: A dictionary with program numbers as keys, and patches as values.
  Values can also be tuple with two items, the first being an init-patch that's executed once every time the
  patch is selected, and the second being the actual patch that processes incoming events.</li>
  <li><b>control</b>: The "control" patch, which is always active, and run in parallel to the current patch.</li>
  <li><b>pre/post</b>: Allows processing to take place before/after every patch. Does not affect
  the control patch.</li>
</ul>


<h4>switch_patch(number)</h4>
<p>
Switches to another patch. This function is similar to the PatchSwitch() object, but can be called from Python.
</p>


<h3><a name="types"></a>Data Types</h3>

<h4>MidiEvent</h4>
<p>
  Used in conjunction with the Call(), CallAsync() and CallThread() units.
</p>
<p>
  A MidiEvent object has the following attributes:
</p>
<ul>
  <li><b>type_</b>: The event type, one of the constants described below.</li>
  <li><b>port_</b>: The event port.</li>
  <li><b>channel_</b>: The event channel.</li>
  <li><b>data1, data2</b>: Data bytes, meaning depends on event type.</li>
</ul>
<p>
There are also aliases for these attributes, some of which are only defined for certain types of events:
</p>
<ul>
  <li><b>port</b>: Event port. Unlike port_, this value is affected by the data_offset setting.</li>
  <li><b>channel</b>: Event channel. Unlike channel_, this value is affected by the data_offset setting.</li>
  <li><b>note</b>: Note number, alias for data1.</li>
  <li><b>velocity</b>: Note velocity, alias for data2.</li>
  <li><b>param</b>: Controller number, alias for data1.</li>
  <li><b>value</b>: Controller parameter, alias for data2.</li>
  <li><b>program</b>: Program number, alias for data2. Unlike data2, this value is affected by the data_offset setting.</li>
</ul>


<h3><a name="constants"></a>Constants</h3>

<h4>Event Types</h4>
<p>
  Every event has one of these types: <b>NOTEON</b>, <b>NOTEOFF</b>, <b>CTRL</b>, <b>PITCHBEND</b>, <b>PROGRAM</b>.<br>
  When building filters, event types can be combined using the bitwise or operator.<br>
  Also defined are <b>NOTE</b> (= NOTEON | NOTEOFF), <b>NONE</b>, <b>ANY</b>.
</p>

<h4>Event Attributes</h4>
<p>
  These constants are used to refer to an event's data attributes:
  <b>EVENT_PORT</b>, <b>EVENT_CHANNEL</b>, <b>EVENT_DATA1</b>, <b>EVENT_DATA2</b>, <b>EVENT_NOTE</b>,
  <b>EVENT_VELOCITY</b>, <b>EVENT_PARAM</b>, <b>EVENT_VALUE</b>, <b>EVENT_PROGRAM</b>.
</p>


<h3><a name="connect"></a>Making Connections</h3>

<h4>A &gt;&gt; B</h4>
<p>
Connects two units in series. Incoming MIDI events will be processed by unit A first, then by unit B.
If the event is filtered out by unit A, it is not processed any further, and unit B will not be called.
</p>

<h4>[ A, B, ... ]</h4>
<p>
Connects two or more units in parallel. All units will be called with identical copies of incoming MIDI
events. The output will be the sum of all the units' outputs.
</p>

<h4>{ T1: A, T2: B, ... }</h4>
<p>
Splits by event type. Equivalent to [ Filter(T1) &gt;&gt; A, Filter(T2) &gt;&gt; B, ... ].
</p>



<h2><a name="units"></a>Units</h2>

<p>
These are the basic building blocks from which you can build your patches.
</p>
<ul>
  <li><b>Filters</b>: These units filter by some property of the MIDI event. If the event matches, it's passed
  unmodified, otherwise it's discarded.
  Events of different types (e.g. a note event going through a CtrlFilter) are also discarded.<br>
  Filters can be inverted by prepending operator ~.</li>
  <li><b>Splits</b>: Basically just combinations of multiple filters of the same kind.</li>
  <li><b>Modifiers</b>: These units change some property of the MIDI event.</li>
  <li><b>Generators</b>: Converters from one event type to another.</li>
  <li><b>Function Calls</b>: These units allow calling back into Python code.</li>
  <li><b>Miscellaneous</b>: Anything that doesn't fit into any of the other categories :)</li>
</ul>


<h3><a name="filters"></a>Filters</h3>

<h4>Filter(type, ...)</h4>
<p>
Filters by one or more event types.
</p>

<h4>PortFilter(port, ...)<br>
ChannelFilter(channel, ...)</h4>
<p>
Filters by event port or channel.
</p>

<h4>KeyFilter(key)<br>
KeyFilter(lower, upper)<br>
KeyFilter(range)</h4>
<p>
Filters by key or key-range. Keys can be MIDI note numbers or note names (e.g. 'g#3').
Ranges can be 2-tuples of note numbers, or note names (e.g. 'g#3:c6').
</p>

<h4>VelocityFilter(min, max)</h4>
<p>
Filters by note velocity.
</p>

<h4>CtrlFilter(ctrl, ...)</h4>
<p>
Filters by CC number.
</p>

<h4>CtrlValueFilter(value)<br>
CtrlValueFilter(min, max)</h4>
<p>
Filters by CC value.
</p>

<h4>ProgFilter(program, ...)</h4>
<p>
Filters by PC number.
</p>


<h3><a name="splits"></a>Splits</h3>

<h4>PortSplit({port: units, ...})<br>
ChannelSplit({channel: units, ...})</h4>
<p>
Splits by port or channel.
</p>

<h4>KeySplit(key, units_lower, units_upper)<br>
KeySplit({(lower, upper): units, ...})<br>
KeySplit({range: units, ...})</h4>
<p>
Splits by key. Non-note events are sent to all units.
</p>

<h4>VelocitySplit(threshold, units_lower, units_upper)<br>
VelocitySplit({(min, max): units, ...})</h4>
<p>
Splits by velocity. Non-note events are sent to all units.
</p>


<h3><a name="modifiers"></a>Modifiers</h3>

<h4>Port(port)<br>
Channel(channel)</h4>
<p>
Changes port or channel.
</p>

<h4>Transpose(offset)</h4>
<p>
Transposes all note events.
</p>

<h4>Velocity(offset)<br>
VelocityFixed(value)</h4>
<p>
Changes velocity, either by adding an offset, or by setting it to a fixed value.
</p>

<h4>VelocityCurve(gamma)</h4>
<p>
Applies a "gamma"-curve to all velocity values.
</p>

<h4>VelocityGradient(note_lower, note_upper, value_lower, value_upper)<br>
VelocityGradientFixed(note_lower, note_upper, value_lower, value_upper)</h4>
<p>
Changes velocity, using a gradient from lower to upper.
</p>

<h4>CtrlMap(ctrl_in, ctrl_out)</h4>
<p>
Maps one controller to another.
</p>

<h4>CtrlRange(ctrl, out_min, out_max, in_min=0, in_max=127)</h4>
<p>
Maps controller range in to out.
</p>


<h3><a name="generators"></a>Generators</h3>

<h4>CtrlChange(ctrl, value)<br>
CtrlChange(port, channel, ctrl, value)<br>
ProgChange(program)<br>
ProgChange(port, channel, program)</h4>
<p>
Changes the type of the event.
If port and channel are omitted, the values of the input event are used.<br>
To "reuse" values from the incoming event, one of the EVENT_* constants can be used in place of any parameter.
</p>


<h3><a name="calls"></a>Function Calls</h3>

<h4>Call(function)</h4>
<p>
Calls a Python function. This will stall any other MIDI processing until the function returns.
</p>
<ul>
  <li><b>function</b>: A function (or any other callable object) that will be called with a MidiEvent
  object as its only argument.<br>
  Possible return values are:
  <ul>
    <li>A single MidiEvent object: output one event and continue processing it.</li>
    <li>A list of MidiEvent objects: output multiple events.</li>
    <li>An empty list or None: discard current event.</li>
  </ul>
  </li>
</ul>

<h4>CallAsync(function)</h4>
<p>
Schedules a Python function for execution, and continues MIDI processing immediately.
</p>
<ul>
  <li><b>function</b>: The function to be called. Unlike Call(), this will run the function in another thread.
  Its return value will be ignored.</li>
</ul>

<h4>CallThread(function)</h4>
<p>
Like CallAsync(), but runs the function in its own thread.
</p>


<h3><a name="misc"></a>Miscellaneous</h3>

<h4>Pass()</h4>
<p>
Does nothing.
</p>

<h4>Discard()</h4>
<p>
Discards the current event.
</p>

<h4>PatchSwitch()<br>
PatchSwitch(number)</h4>
<p>
Switches to another patch.
number should be a patch number, or one of the EVENT_* constants.
Without parameters, the program number of the incoming event (should be a program change) will be used.
</p>

<h4>Print(name=None, types=ANY, portnames=Print.PORTNAMES_NONE)</h4>
<p>
Prints event data.
<ul>
  <li><b>name</b>: A string to be printed before each event.</li>
  <li><b>types</b>: Restricts printing to certain event types, using a combination of the event type constants described above.</li>
  <li><b>portnames</b>: Pass Print.PORTNAMES_IN or Print.PORTNAMES_OUT to print input or output portnames,
  rather than just numbers.</li>
</ul>

<h4>PrintString(string)</h4>
<p>
Prints a fixed string.
</p>

<h4>Sanitize()</h4>
<p>
Makes sure the event is a valid MIDI message. Events with invalid port, channel, controller, program or note number are
discarded, note velocity and controller values are confined to the range 0-127.
</p>



<h2><a name="examples"></a>Examples</h2>

<ul>
  <li><a href="./example.py">example.py</a> - a very simple mididings setup</li>
  <li><a href="./example_patches.py">example_patches.py</a> - a simple example setup, demonstrating patch switching</li>
  <li><a href="./example_python.py">example_python.py</a> - shows how to process MIDI events in Python</li>
</ul>


</body>

</html>
