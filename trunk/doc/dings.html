<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">

<head>
  <title>mididings - Documentation</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <style type="text/css">
    body { max-width: 60em; font-size: 90%; font-family: sans-serif; }
    h1 { font-size: 130%; color: #333; background: #eee; padding: 4px 0.7em; }
    h2 { font-size: 110%; color: #fff; background: #667; padding: 4px 0.7em; margin-top: 1.5em; }
    h3 { font-size: 100%; color: #333; background: #dddde5; padding: 4px 0.7em; margin-top: 1.5em; }
    h4 { font-size: 100%; color: #333; padding-left: 0.5em; margin-bottom: 0.4em; }
    p,table,pre { margin-left: 1.6em; margin-top: 0.4em; }
    b { color: #333; }
    pre { font-size: 110%; }
    table { border: 1px solid #333; border-collapse: collapse; }
    th, td { border: 1px solid #333; padding: 0em 0.3em; }
    th { color: #333; text-align: left; background: #eee; }
    a { font-weight: bold; color: #237; }
  </style>
</head>

<body>

<h1>mididings - Documentation</h1>

<h2>Table of Contents</h2>
<ul>
  <li><a href="#basics">Basics</a>
    <ul>
      <li><a href="#functions">Functions</a></li>
      <li><a href="#types">Data Types</a></li>
      <li><a href="#constants">Constants</a></li>
      <li><a href="#connect">Making Connections</a></li>
    </ul>
  </li>

  <li><a href="#units">Units</a>
    <ul>
      <li><a href="#filters">Filters</a></li>
      <li><a href="#splits">Splits</a></li>
      <li><a href="#modifiers">Modifiers</a></li>
      <li><a href="#generators">Generators</a></li>
      <li><a href="#calls">Function Calls</a></li>
      <li><a href="#misc">Miscellaneous</a></li>
    </ul>
  </li>

  <li><a href="#extra">Additional Units and Hooks</a></li>

  <li><a href="#examples">Examples</a></li>
</ul>



<h2><a name="basics"></a>Basics</h2>

<p>
mididings configuration files are just Python scripts, although mididings uses some of Python's features in ways
for which they weren't intended ;)<br>
Basically, the MIDI processing setup is defined in Python, while the actual event processing is done entirely
in C++. It is however possible to explicitly call back into Python, if necessary.
</p>


<h3><a name="functions"></a>Functions</h3>

<h4>config(**kwargs)</h4>
<p>
Changes global mididings settings. This should be called only once, before constructing any processing units.
<br>
Possible keyword arguments are:
</p>
<ul>
  <li><b>backend</b>: MIDI backend to be used:
  <ul>
    <li>'alsa': Use the ALSA sequencer (this is the default).</li>
    <li>'jack': Use JACK MIDI. All MIDI events are buffered and processed outside the JACK process callback,
    and will thus be delayed by (at least) one period.</li>
    <li>'jack-rt': MIDI events are processed directly in the JACK process callback. It's not safe to run Python
    code in a realtime context, so it's recommended to avoid Process(), which <i>might</i> cause xruns (or worse).
    All other units should be safe to use.</li>
  </ul>
  </li>
  <li><b>client_name</b>: MIDI client name to be used.</li>
  <li><b>in_ports/out_ports</b>: Integers indicating the number of input/output ports to create (named in_<i>n</i>
  or out_<i>n</i>), or lists of port names, in which case the list's length determines the number of ports.</li>
  <li><b>data_offset</b>: 1 (default) or 0. Determines whether program, port and channel numbers will be
  in the range 1-128 or 0-127.</li>
  <li><b>octave_offset</b>: Default is 2, meaning that "middle C" is designated as C3.</li>
  <li><b>initial_scene</b>: The number of the first scene to be activated.</li>
  <li><b>start_delay</b>: The number of seconds before sending any MIDI events (i.e. switching to the first scene).
  A small value like 0.5 can be used to give tools like qjackctl's patchbay time to connect the ports.
  A value of 0 instructs mididings to wait for the user to press enter. Default is None.</li>
</ul>


<h4>hook(*args)</h4>
<p>
Registers "hook" objects, that can be used to extend the functionality of mididings.
</p>


<h4>run(patch)</h4>
<p>
Starts the MIDI processing. This is usually the last function called by a mididings script.
</p>
<ul>
  <li><b>patch</b>: A single patch.</li>
</ul>

<h4>run(scenes=..., control=None, pre=None, post=None)</h4>
<p>
Starts the MIDI processing, using multiple scenes.
The SceneSwitch() unit can be used to switch between these scenes.
</p>
<ul>
  <li><b>scenes</b>: A dictionary with program numbers as keys, and patches as values.
  Values can also be tuples with two items, the first being an init-patch that's executed once every time the
  scenes is selected, and the second being the actual patch that processes incoming events.</li>
  <li><b>control</b>: The "control" patch, which is always active, and runs in parallel to the current scene.</li>
  <li><b>pre/post</b>: Allows processing to take place before/after every scene. Does not affect
  the control patch.</li>
</ul>


<h4>process_file(infile, outfile, patch)</h4>
<p>
<i>Requires mididings to be compiled with support for <a href="http://sourceforge.net/projects/libsmf/">libsmf</a>.</i><br>
Reads a standard MIDI file, processes it, then writes the result back to a file.
</p>


<h3><a name="types"></a>Data Types</h3>

<h4>MidiEvent</h4>
<p>
  Used in conjunction with the Process() and Call() units.
</p>
<p>
  A MidiEvent object has the following attributes:
</p>
<ul>
  <li><b>type</b>: The event type, one of the constants described below.</li>
  <li><b>port</b>: The event port.</li>
  <li><b>channel</b>: The event channel.</li>
  <li><b>data1, data2</b>: Data bytes, meaning depends on event type.</li>
</ul>
<p>
There are also aliases for these attributes, some of which are only valid for certain types of events:
</p>
<ul>
  <li><b>note</b>: Note number, alias for data1.</li>
  <li><b>velocity</b>: Note velocity, alias for data2.</li>
  <li><b>param</b>: Controller number, alias for data1.</li>
  <li><b>value</b>: Controller parameter, alias for data2.</li>
  <li><b>program</b>: Program number, alias for data2. Unlike data2, this value is affected by the data_offset setting.</li>
</ul>


<h3><a name="constants"></a>Constants</h3>

<h4>Event Types</h4>
<p>
  Every event has one of these types:
</p>
<ul>
  <li><b>NOTEON</b></li>
  <li><b>NOTEOFF</b></li>
  <li><b>CTRL</b></li>
  <li><b>PROG</b></li>
  <li><b>PITCHBEND</b></li>
  <li><b>AFTERTOUCH</b></li>
  <li><b>POLY_AFTERTOUCH</b></li>
  <li><b>SYSEX</b></li>
  <li><b>SYSCM_QFRAME</b></li>
  <li><b>SYSCM_SONGPOS</b></li>
  <li><b>SYSCM_SONGSEL</b></li>
  <li><b>SYSCM_TUNEREQ</b></li>
  <li><b>SYSRT_CLOCK</b></li>
  <li><b>SYSRT_START</b></li>
  <li><b>SYSRT_CONTINUE</b></li>
  <li><b>SYSRT_STOP</b></li>
  <li><b>SYSRT_SENSING</b></li>
  <li><b>SYSRT_RESET</b></li>
</ul>
<p>
  For use in filters, the following constants are also defined:
</p>
<ul>
  <li><b>NOTE</b> = NOTEON | NOTEOFF</li>
  <li><b>SYSCM</b> = SYSCM_*</li>
  <li><b>SYSRT</b> = SYSRT_*</li>
  <li><b>NONE</b></li>
  <li><b>ANY</b></li>
</ul>
<p>
  When building filters, event types can be combined using | (bitwise or) and ~ (bitwise negation).<br>
</p>

<h4>Event Attributes</h4>
<p>
  These constants are used to refer to an event's data attributes:
</p>
<ul>
  <li><b>EVENT_PORT</b></li>
  <li><b>EVENT_CHANNEL</b></li>
  <li><b>EVENT_DATA1</b></li>
  <li><b>EVENT_DATA2</b></li>
  <li><b>EVENT_NOTE</b></li>
  <li><b>EVENT_VELOCITY</b></li>
  <li><b>EVENT_PARAM</b></li>
  <li><b>EVENT_VALUE</b></li>
  <li><b>EVENT_PROGRAM</b></li>
</ul>


<h3><a name="connect"></a>Making Connections</h3>

<h4>A &gt;&gt; B</h4>
<p>
Connects two units in series. Incoming MIDI events will be processed by unit A first, then by unit B.
If the event is filtered out by unit A, it is not processed any further, and unit B will not be called.
</p>

<h4>A // B</h4>
<p>
Connects two units in parallel. Both units will be called with identical copies of incoming MIDI
events. The output will be the sum of all the units' outputs.
Note that operator // has higher precedence than &gt;&gt;.
</p>

<h4>[ A, B, ... ]</h4>
<p>
Connects an arbitrary number of units in parallel.
</p>

<h4>Fork([ A, B, ... ], types=ANY, remove_duplicates=True)</h4>
<p>
Same as the above, with some additional features:
</p>
<ul>
  <li><b>types</b>: Pass something other than ANY to process only certain types of events, and leave
  other events unchanged.</li>
  <li><b>remove_duplicates</b>: Whether duplicates should be discarded when two or more units yield identical MIDI events.</li>
</ul>
<p>
Using Fork() explicitly (instead of just a list) is also useful in situations where both sides of operator &gt;&gt;
would otherwise be lists, which Python does not allow.
</p>

<h4>{ T1: A, T2: B, ... }</h4>
<p>
Splits by event type.
Equivalent to [ Filter(T1) &gt;&gt; A, Filter(T2) &gt;&gt; B, ... ].
</p>

<h4>Split({ T1: A, T2: B, ... })</h4>
<p>
Same as the above. Like Fork(), this can be useful to make operator &gt;&gt; work.
</p>

<h4>~F</h4>
<p>
Inverts the filter F. Note that for filters which only affect certain kinds of events,
other events will remain unaffected when the filter is inverted.
For example, an inverted KeyFilter will match a different note range, but neither the original nor the inverted
filter will have any effect on control or program changes.
</p>

<h4>-F</h4>
<p>
Inverts the filter F. Unlike ~F, -F matches exactly the events that F doesn't.
</p>

<h4>F % A</h4>
<p>
Applies A only to events which match filter F, but keeps events which don't.
Equivalent to [ F &gt;&gt; A, -F ].
</p>

<h4>(F1 & F2 & ...) % A</h4>
<p>
Applies A only to events which match all filters F1, F2, etc.
</p>


<h2><a name="units"></a>Units</h2>

<p>
These are the basic building blocks from which you can build your patches.
</p>
<ul>
  <li><b>Filters</b>: These units filter by some property of the MIDI event. If the event matches, it's passed
  unmodified, otherwise it's discarded.</li>
  <li><b>Splits</b>: Basically just combinations of multiple filters of the same kind.</li>
  <li><b>Modifiers</b>: These units change some property of the MIDI event.</li>
  <li><b>Generators</b>: Converters from one event type to another.</li>
  <li><b>Function Calls</b>: These units allow calling back into Python code.</li>
  <li><b>Miscellaneous</b>: Anything that doesn't fit into any of the other categories :)</li>
</ul>


<h3><a name="filters"></a>Filters</h3>

<h4>Filter(type, ...)</h4>
<p>
Filters by one or more event types.
</p>

<h4>PortFilter(port, ...)<br>
ChannelFilter(channel, ...)</h4>
<p>
Filters by event port or channel.
</p>

<h4>KeyFilter(key)<br>
KeyFilter(lower, upper)<br>
KeyFilter(key_range)</h4>
<p>
Filters by key or key-range. Keys can be MIDI note numbers or note names (e.g. 'g#3').
Ranges can be 2-tuples of note numbers, or note names (e.g. 'g#3:c6').
</p>

<h4>VelocityFilter(value)<br>
VelocityFilter(lower, upper)</h4>
<p>
Filters by note velocity. A lower or upper value of 0 means no limit.
</p>

<h4>CtrlFilter(ctrl, ...)</h4>
<p>
Filters by CC number.
</p>

<h4>CtrlValueFilter(value)<br>
CtrlValueFilter(lower, upper)</h4>
<p>
Filters by CC value.
</p>

<h4>ProgFilter(program, ...)</h4>
<p>
Filters by PC number.
</p>

<h4>SysExFilter(sysex)</h4>
<p>
Filters by sysex data, specified as a string or as a sequence of integers.
If sysex does end with F7, partial matches that start with the given data bytes are accepted.
</p>

<h4>SysExFilter(manufacturer=...)</h4>
<p>
Filters by sysex manufacturer id, which can be a string or a sequence of integers, with a length of one or three bytes.
</p>


<h3><a name="splits"></a>Splits</h3>

<h4>PortSplit({port: patch, ...})<br>
PortSplit({(port, ...): patch, ...})<br>
ChannelSplit({channel: patch, ...})<br>
ChannelSplit({(channel, ...): patch, ...})</h4>
<p>
Splits by port or channel.
</p>

<h4>KeySplit(key, patch_lower, patch_upper)<br>
KeySplit({(lower, upper): patch, ...})<br>
KeySplit({key_range: patch, ...})</h4>
<p>
Splits by key. Non-note events are sent to all units.
</p>

<h4>VelocitySplit(threshold, patch_lower, patch_upper)<br>
VelocitySplit({(lower, upper): patch, ...})</h4>
<p>
Splits by velocity. Non-note events are sent to all units.
</p>

<h4>CtrlSplit({ctrl: patch, ...})<br>
CtrlSplit({(ctrl, ...): patch, ...})</h4>
<p>
Splits by controller number.
Non-controller events are left unchanged, but not sent to any of the units.
</p>

<h4>CtrlValueSplit(threshold, patch_lower, patch_upper)<br>
CtrlValueSplit({value: patch, ...})<br>
CtrlValueSplit({(lower, upper): patch, ...})</h4>
<p>
Splits by controller value.
Non-controller events are left unchanged, but not sent to any of the units.
</p>

<h4>ProgSplit({program: patch, ...})<br>
ProgSplit({(program, ...): patch, ...})</h4>
<p>
Splits by program number.
Non-program-change events are left unchanged, but not sent to any of the units.
</p>

<h4>SysExSplit({sysex: patch, ...})<br>
SysExSplit(manufacturers={manufacturer: patch, ...})</h4>
<p>
Splits by sysex data or manufacturer id.
</p>


<h3><a name="modifiers"></a>Modifiers</h3>

<h4>Port(port)<br>
Channel(channel)</h4>
<p>
Changes port or channel.
</p>

<h4>Transpose(offset)</h4>
<p>
Transposes all note events.
</p>

<h4>Velocity(offset)<br>
Velocity(multiply=...)<br>
Velocity(fixed=...)<br>
Velocity(gamma=...)<br>
Velocity(curve=...)</h4>
<p>
Changes velocity by adding an offset, multiplying with a factor, setting it to a fixed value, or applying a velocity-curve.<br>
gamma uses a quadratic function, where values greater than 1 increase velocity, while values between 0 and 1 decrease it.
curve uses a somewhat smoother exponential function, where positive values increase velocity, while negative values decrease it.
</p>

<h4>VelocitySlope(notes, offset)<br>
VelocitySlope(notes, multiply=...)<br>
VelocitySlope(notes, fixed=...)<br>
VelocitySlope(notes, gamma=...)<br>
VelocitySlope(notes, curve=...)</h4>
<p>
Changes velocity, applying a linear slope between different notes.
Both parameters must be lists/tuples of the same length, where one velocity value corresponds to each note.<br>
This can be used for example to fade-in a sound over a region of the keyboard.
</p>

<h4>VelocityLimit(lower, upper)</h4>
<p>
Confines velocity to values between lower and upper (inclusive).
</p>

<h4>CtrlMap(ctrl_in, ctrl_out)</h4>
<p>
Maps one controller to another (i.e. changes the CC number).
</p>

<h4>CtrlRange(ctrl, out_min, out_max, in_min=0, in_max=127)</h4>
<p>
Maps controller range in to out.<br>
An input value of in_min or less results in an output value of out_min.
Likewise, an in value of in_max or greater results in an output value of out_max.
</p>


<h3><a name="generators"></a>Generators</h3>

<h4>CtrlChange(ctrl, value)<br>
CtrlChange(port, channel, ctrl, value)<br>
ProgChange(program)<br>
ProgChange(port, channel, program)<br>
NoteOn(note, velocity)<br>
NoteOn(port, channel, note, velocity)<br>
NoteOff(note, velocity)<br>
NoteOff(port, channel, note, velocity)</h4>
<p>
Changes the type of the event.
If port and channel are omitted, the values of the input event are used.<br>
To "reuse" other values from the incoming event, one of the EVENT_* constants can be used in place of any parameter.
</p>

<h4>SysEx(sysex)<br>
SysEx(port, sysex)</h4>
<p>
Creates a new system exclusive event. sysex can be a string or a sequence of integers, and must include the leading F0 and trailing F7 bytes.
</p>

<h4>Generator(type, port, channel, data1=0, data2=0)</h4>
<p>
Generic generator. System common and system realtime events can only be generated this way.
</p>


<h3><a name="calls"></a>Function Calls</h3>

<h4>Process(function)</h4>
<p>
Calls a Python function. This will stall any other MIDI processing until the function returns.
</p>
<ul>
  <li><b>function</b>: A function (or any other callable object) that will be called with MidiEvent
  objects as its only argument.<br>
  Possible return values are:
  <ul>
    <li>A single MidiEvent object: output one event and continue processing it.</li>
    <li>A list of MidiEvent objects: output multiple events.</li>
    <li>An empty list or None: discard current event.</li>
  </ul>
  </li>
</ul>

<h4>Call(function)</h4>
<p>
Schedules a Python function for execution, and continues MIDI processing immediately.
</p>
<ul>
  <li><b>function</b>: The function to be called. Unlike Process(), this will run the function in another thread.
  Its return value will be ignored.</li>
</ul>

<h4>Call(thread=...)</h4>
<p>
Like Call(), but runs the function in its own thread.
</p>

<h4>System(cmd)</h4>
<p>
Runs an arbitrary shell command, without waiting for the command to complete.
</p>
<ul>
  <li><b>cmd</b>: The command as a string, or a Python function taking a single MidiEvent parameter and returning a string.</li>
</ul>


<h3><a name="misc"></a>Miscellaneous</h3>

<h4>Pass()</h4>
<p>
Does nothing.
</p>

<h4>Discard()</h4>
<p>
Discards the current event.
</p>

<h4>SceneSwitch()<br>
SceneSwitch(number)</h4>
<p>
Switches to another scene.
number should be a scene number, or one of the EVENT_* constants.
Without parameters, the program number of the incoming event (should be a program change) will be used.
</p>

<h4>Init(patch)</h4>
<p>
Executes patch when switching to the scene containing this unit (essentially adding it to the init-patch,
see run() for more information).
</p>

<h4>Output(port, channel, program=None, volume=None)</h4>
<p>
Routes incoming events to the specified port/channel.
Optionally, when switching to the scene containing this unit, a program change and/or volume change (CC 7) can be sent.
To send a bank select in addition to the program change, program can be a tuple with two elements, where the first element
is the bank number, and the second is the program number.
</p>

<h4>Print(name=None, types=ANY, portnames=None)</h4>
<p>
Prints event data.
</p>
<ul>
  <li><b>name</b>: A string to be printed before each event.</li>
  <li><b>types</b>: Restricts printing to certain event types, using a combination of the event type constants described above.</li>
  <li><b>portnames</b>: Pass 'in' or 'out' to print input or output portnames, rather than just numbers.</li>
</ul>

<h4>Print(string=...)</h4>
<p>
Prints a fixed string.
</p>

<h4>Sanitize()</h4>
<p>
Makes sure the event is a valid MIDI message. Events with invalid port, channel, controller, program or note number are
discarded, note velocity and controller values are confined to the range 0-127.
</p>



<h2><a name="extra"></a>Additional Units and Hooks</h2>

<p>
These units are defined in the mididings.extra module, and offer some more advanced/specific functionality,
based on the more basic mididings units.<br>
Some of these are implemented in Python using Process(), and thus not safe to use with the jack-rt backend.
</p>


<h4>Harmonize(tonic, scale, interval, non_harmonic='below')</h4>
<p>
A diatonic harmonizer.
</p>
<ul>
  <li><b>tonic</b>: The tonic of the scale.</li>
  <li><b>scale</b>: One of:<br>
  'major', 'minor', 'minor_harmonic', 'ionian', 'dorian', 'phrygian', 'lydian', 'mixolydian', 'aeolian', 'locrian'.</li>
  <li><b>interval</b>: The number of steps to transpose the notes by, or one of these interval names:<br>
  'unison', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'octave',
  'ninth', 'tenth', 'eleventh', 'twelfth', 'thirteenth'.<br>
  It's also possible to pass a list of intervals, to create multiple harmonized voices.</li>
  <li><b>non_harmonic</b>: What to do with out-of-scale notes:
  <ul>
    <li>'skip': Ignore note.</li>
    <li>'same': Output note as is, without transposing it.</li>
    <li>'below'/'above': Transpose by the same interval as the next on-scale note below/above.</li>
  </ul>
  </li>
</ul>

<h4>LimitPolyphony(max_polyphony, remove_oldest=True)</h4>
<p>
Limits the "MIDI polyphony" to max_polyphony.
If remove_oldest is true, the oldest notes will be stopped when the maximum polyphony is exceeded.
If remove_oldest is false, no new notes are accepted while max_polyphony notes are held.<br>
Note that the actual polyphony of a connected synthesizer can still be higher than the limit set here,
e.g. due to a long release phase.
</p>

<h4>MakeMonophonic()</h4>
<p>
Makes the MIDI signal "monophonic", i.e. only one note can be played at any given time.
When a note is released while another one is still held (but silent), the previous one will be retriggered.
</p>

<h4>SuppressPC()</h4>
<p>
Filters out program changes if the same program had previously been selected on the same port/channel.
</p>

<h4>PedalToNoteoff(ctrl=64, sostenuto=False)</h4>
<p>
Converts sustain pedal CCs to note-off events (delaying note-offs until the pedal is released).
Acts either like a regular sustain pedal (the default) or like a sostenuto pedal.
</p>

<h4>BlackKeys()<br>
WhiteKeys()</h4>
<p>
Filters notes by key color.
</p>

<h4>MemorizeScene(memo_file)</h4>
<p>
A hook object that saves the currently selected scene number to a file when terminating mididings, and restores it at the next startup.
memo_file is the path of the file to be used to store the scene number.
</p>

<h4>OSCInterface(port)</h4>
<p>
<i>Defined in mididings.extra.osc. Requires <a href="http://das.nasophon.de/pyliblo/">pyliblo</a>.</i><br>
A hook object that allows controlling mididings via OSC. These messages are currently understood:
</p>
<ul>
  <li><b>/mididings/switch_scene ,i</b>: switches to the given scene number.</li>
  <li><b>/mididings/quit</b>: terminates mididings.</li>
</ul>

<h4>SendOSC(target, path, ...)</h4>
<p>
<i>Defined in mididings.extra.osc. Requires <a href="http://das.nasophon.de/pyliblo/">pyliblo</a>.</i><br>
Sends an OSC message. Parameters are the same as for liblo.send().
Additionally, rather than a concrete value, each data argument can be a Python function instead.
The function should then take a single MidiEvent parameter, and return the value to be sent.
</p>

<h4>SendDBUS(service, path, interface, method, ...)</h4>
<p>
<i>Defined in mididings.extra.dbus. Requires dbus-python.</i><br>
Sends a DBUS message. Rather than a concrete value, each data argument can be a Python function instead.
The function should then take a single MidiEvent parameter, and return the value to be sent.
</p>

<h4>AutoRestart(modules=True, filenames=[])</h4>
<p>
<i>Defined in mididings.extra.inotify. Requires <a href="http://trac.dbzteam.org/pyinotify">pyinotify</a> &ge; 0.8.</i><br>
A hook object that automatically restarts mididings when the script changes.
If modules is True, all imported local Python modules are monitored for changes as well.
The filenames parameter allows specifying additional files to be monitored.<br>
This restarts the entire mididings script, so MIDI processing is interrupted, and mididings does not take care of
reestablishing any ALSA/JACK connections.
If the new script contains errors that prevent it from running, mididings exits and needs to be restarted manually
once the errors are fixed.
</p>


<h2><a name="examples"></a>Examples</h2>

<ul>
  <li><a href="./examples/transpose.py">transpose.py</a> - probably the most simple example that actually does something useful ;)</li>
  <li><a href="./examples/connections.py">connections.py</a> - how to connect units in series or in parallel,
  and how to split by event type or channel</li>
  <li><a href="./examples/filters.py">filters.py</a> - how to use filters</li>
  <li><a href="./examples/print.py">print.py</a> - printing MIDI events to stdout</li>
  <li><a href="./examples/output.py">output.py</a> - uses the Output() unit to simplify MIDI routing and sending program changes</li>
  <li><a href="./examples/process.py">process.py</a> - shows how to process MIDI events in Python</li>
  <li><a href="./examples/harmonizer.py">harmonizer.py</a> - example usage of the diatonic harmonizer</li>
  <li><a href="./examples/aeolus.py">aeolus.py</a> - <a href="http://www.kokkinizita.net/linuxaudio/aeolus/index.html">Aeolus</a>
  stop control using one controller per stop</li>
  <li><a href="./examples/klick.py">klick.py</a> - uses SendOSC() to start/stop <a href="http://das.nasophon.de/klick/">klick</a>,
  or change its tempo</li>
</ul>


</body>

</html>
